/**
 * Copyright (c) 2018, NiftySoft LLC.
 *
 * This file is part of Stochrammar.
 *
 * Stochrammar is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Stochrammar is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Stochrammar.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.nifty.stochrammar.runner;

import com.nifty.stochrammar.GrammarToken;
import com.nifty.stochrammar.StochasticGrammar;

import java.util.Arrays;
import java.util.Random;
import java.util.Stack;

/**
 * TreeRunner provides an algorithm for running a StochasticGrammar. GrammarTokens generated by the grammar are
 * stored in a tree. The act() methods are applied to a blankEntity object via a tree traversal starting at the root.
 *
 * @param <T>
 */
public class TreeRunner<T> extends GrammarRunner<T> {

    public static enum TraversalType {
        POST_ORDER,
        PRE_ORDER
    }

    private TreeNode root;
    private TraversalType traversalType = TraversalType.PRE_ORDER;

    public TreeRunner(StochasticGrammar<T> grammar) {
        super(grammar);
    }

    @Override
    public T run(Random rand) {
        generateTree(rand);
        return generateEntity();
    }

    public void setTraversalType(TraversalType traversalType) {
        this.traversalType = traversalType;
    }

    private void generateTree(Random rand) {
        Stack<TreeNode> frontier = new Stack<>();

        root = new TreeNode(grammar.generateRootToken());
        frontier.push(root);
        while(!frontier.isEmpty()) {
            TreeNode<T> node = frontier.pop();

            GrammarToken[] tokens = node.token.replace(rand);
            if (tokens != null) {
                node.addChildren(tokens);
                for (int i = 0; i < tokens.length; ++i) {
                    frontier.push(new TreeNode(tokens[i]));
                }
            }
        }
    }

    private T generateEntity() {
        T result = grammar.blankEntity();
        generateEntity(root, result);
        return result;
    }

    private void generateEntity(TreeNode<T> curr, T entity) {
        if (traversalType == TraversalType.PRE_ORDER) {
            curr.token.act(entity);
        }
        for (int i = 0; i < curr.nChildren; ++i) {
            generateEntity(curr, entity);
        }
        if (traversalType == TraversalType.POST_ORDER) {
            curr.token.act(entity);
        }
    }

    /**
     * TreeNode wraps GrammarToken, providing an n-ary tree structure on top of it.
     * @param <T>
     */
    private static class TreeNode<T> {
        // The default number of slots to allocate a new TreeNode.
        private static final int DEFAULT_ARITY = 4;
        private TreeNode[] children;
        private int nChildren = 0;
        private GrammarToken<T> token;

        public TreeNode(GrammarToken<T> token) {
            this(token, DEFAULT_ARITY);
        }

        public TreeNode(GrammarToken<T> token, int arity) {
            this.children = new TreeNode[4];
        }

        public void addChildren(GrammarToken<T>... tokens) {
            if (nChildren + tokens.length < children.length) {
                int newLen = Math.max(children.length*2, nChildren + tokens.length);
                children = Arrays.copyOf(children, newLen);
            }
            System.arraycopy(tokens, 0, children, nChildren, tokens.length);
        }
    }

}
