/**
 * Copyright (c) 2018, NiftySoft LLC.
 *
 * This file is part of Stochrammar.
 *
 * Stochrammar is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Stochrammar is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Stochrammar.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.nifty.stochrammar.runner;

import com.nifty.stochrammar.GrammarToken;
import com.nifty.stochrammar.StochasticGrammar;

import java.util.*;

/**
 * TreeRunner provides an algorithm for running a StochasticGrammar. GrammarTokens generated by the grammar are
 * stored in a tree. The act() methods are applied to a blankEntity object via a depth-first tree traversal starting at
 * the root.
 *
 * @param <T>
 */
public class TreeRunner<T> extends GrammarRunner<T> {
    // TODO: This would be much more performant if it didn't construct an actual tree at all.

    public static enum TraversalType {
        POST_ORDER,
        PRE_ORDER,
        LEVEL_ORDER
    }

    private TreeNode root;
    private TraversalType traversalType = TraversalType.PRE_ORDER;

    public TreeRunner(StochasticGrammar<T> grammar) {
        super(grammar);
    }

    @Override
    public T run(Random rand) {
        generateTree(rand);
        return generateEntity();
    }

    public void setTraversalType(TraversalType traversalType) {
        this.traversalType = traversalType;
    }

    private void generateTree(Random rand) {
        Stack<TreeNode> frontier = new Stack<>();

        root = new TreeNode(grammar.generateRootToken());
        frontier.push(root);
        while(!frontier.isEmpty()) {
            TreeNode<T> node = frontier.pop();

            GrammarToken[] tokens = node.token.replace(rand);
            if (tokens != null) {
                node.addChildren(tokens);
                for (int i = 0; i < tokens.length; ++i) {
                    frontier.push(new TreeNode(tokens[i]));
                }
            }
        }
    }

    private T generateEntity() {
        TraversalSequence sequence;
        switch (traversalType) {
            default:
            case POST_ORDER:
            case PRE_ORDER:
                sequence = new TraversalStack();
                break;
            case LEVEL_ORDER:
                sequence = new TraversalQueue();
                break;
        }
        T entity = grammar.blankEntity();
        sequence.add(root);
        while(!sequence.isEmpty()) {
            TreeNode curr = sequence.next();

            if (traversalType == TraversalType.PRE_ORDER) {
                curr.token.act(entity);
            }
            for (int i = 0; i < curr.nChildren; ++i) {
                sequence.add(curr.children[i]);
            }
            if (traversalType == TraversalType.POST_ORDER ||
                traversalType == TraversalType.LEVEL_ORDER) {
                curr.token.act(entity);
            }
        }
        return entity;
    }

    /**
     * TraversalList provides an interface for sequential data structures used for tree traversal.
     */
    private interface TraversalSequence {
        void add(TreeNode node);
        TreeNode next();
        boolean isEmpty();
    }

    private static class TraversalStack implements TraversalSequence {

        private Stack<TreeNode> stack;
        public TraversalStack() { this.stack = new Stack<>(); }

        @Override
        public void add(TreeNode node) { stack.push(node); }

        @Override
        public TreeNode next() { return stack.pop(); }

        @Override
        public boolean isEmpty() {
            return stack.isEmpty();
        }
    }

    private static class TraversalQueue implements TraversalSequence {
        private Queue<TreeNode> queue;
        public TraversalQueue() { this.queue = new LinkedList<>(); }

        @Override
        public void add(TreeNode node) { queue.add(node); }

        @Override
        public TreeNode next() { return queue.remove(); }

        @Override
        public boolean isEmpty() {
            return queue.isEmpty();
        }
    }

    /**
     * TreeNode wraps GrammarToken, providing an n-ary tree structure on top of it.
     * @param <T>
     */
    private static class TreeNode<T> {
        // The default number of slots to allocate a new TreeNode.
        private static final int DEFAULT_ARITY = 4;
        private TreeNode[] children;
        private int nChildren = 0;
        private GrammarToken<T> token;

        public TreeNode(GrammarToken<T> token) {
            this(token, DEFAULT_ARITY);
        }

        public TreeNode(GrammarToken<T> token, int arity) {
            this.children = new TreeNode[4];
        }

        public void addChildren(GrammarToken<T>... tokens) {
            if (nChildren + tokens.length < children.length) {
                int newLen = Math.max(children.length*2, nChildren + tokens.length);
                children = Arrays.copyOf(children, newLen);
            }
            System.arraycopy(tokens, 0, children, nChildren, tokens.length);
        }
    }

}
