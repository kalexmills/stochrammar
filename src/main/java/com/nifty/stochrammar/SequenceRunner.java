// Copyright (c) 2018, NiftySoft LLC. All Rights Reserved.
package com.nifty.stochrammar;

import java.util.Arrays;
import java.util.Random;

/**
 * SequenceRunner provides a default algorithm for running a StochasticGrammar. GroundTokens generated by the grammar
 * are stored in a flattened sequence, and the act() methods are applied starting with a blank instance, and applying
 * each token in order of the sequence.
 *
 * This works well for grammars whose act() operations are commutative and associative. If a different control-flow is
 * required to control the complex interaction of act() methods, other runners may be more appropriate.
 *
 * The implementation used here involves double-buffering using two dynamic arrays. The buffers are not disposed of
 * between calls to run(), so if your grammars can generate strings of tokens which are particularly large, it is
 * certainly more memory efficient to have only one SequenceRunner in memory that is shared by all clients.
 */
public class SequenceRunner<T> extends GrammarRunner<T> {
    private static final int DEFAULT_BUFFER_SIZE = 32;

    // Null-terminated buffers used to collect tokens as they are created.
    // N.B.: A more space-efficient implementation would probably use one set of buffers per running thread.
    private GrammarToken[] tokenBuffer;
    private GrammarToken[] backBuffer;

    public SequenceRunner(StochasticGrammar<T> grammar) {
        super(grammar);
        tokenBuffer = new GrammarToken[DEFAULT_BUFFER_SIZE];
        backBuffer = new GrammarToken[DEFAULT_BUFFER_SIZE];
    }

    /**
     * Stochastically generates a new object of type T using the Random instance passed.
     *
     * @param rand Random a pre-seeded random number generator to be used for the generation.
     * @return T an instance of type T which results from the generation.
     */
    public T run(Random rand) {
        // While a faster implementation might do some extra work to avoid calls to known GroundTokens, this will
        // only yield a practical speedup in the presence of a very large number of tokens. It may become necessary
        // at some later stage.
        tokenBuffer[0] = grammar.generateRootToken();
        tokenBuffer[1] = null;

        boolean tokensChanged = true;

        // Generates a string of GroundTokens.
        while (tokensChanged) {
            tokensChanged = false;

            int i = 0; // i indexes tokenBuffer
            int j = 0; // j indexes backBuffer
            while(i < tokenBuffer.length && tokenBuffer[i] != null) {
                GrammarToken[] tokens = tokenBuffer[i++].replace(rand);
                if(tokens != null) {
                    tokensChanged = true;
                    for (int k = 0; k < tokens.length; k++) {
                        backBuffer[j++] = tokens[k];
                        if(j >= backBuffer.length) extendBackBuffer();
                    }
                    backBuffer[j] = null; // Ensure back buffer remains null-terminated.
                } else {
                    // We received null: this was a ground token, so we need to keep it.
                    backBuffer[j++] = tokenBuffer[i-1];
                    if(j >= backBuffer.length) extendBackBuffer();
                }
            }
            if(tokensChanged) {
                swapBuffers();
            }
        }

        // Each token acts on a blank instance of type T, in sequence.
        T result = grammar.blank();
        int i = 0;
        while (tokenBuffer[i] != null) {
            result = ((GroundToken<T>)tokenBuffer[i++]).act(result);
        }
        return result;
    }

    /**
     * extendBackBuffer doubles the size of the back buffer. This change eventually propagates to the front buffer,
     * which means it is usually invoked twice whenever extensions are needed.
     */
    private void extendBackBuffer() {
        backBuffer = Arrays.copyOf(backBuffer, backBuffer.length * 2);
    }

    /**
     * swapBuffers swaps the front and back buffers.
     */
    private void swapBuffers() {
        GrammarToken[] temp = tokenBuffer;
        tokenBuffer = backBuffer;
        backBuffer = temp;
    }
}