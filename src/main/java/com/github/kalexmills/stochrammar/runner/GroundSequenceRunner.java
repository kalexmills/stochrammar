/**
 * Copyright (c) 2018, NiftySoft LLC.
 *
 * This file is part of Stochrammar.
 *
 * Stochrammar is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Stochrammar is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Stochrammar.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.github.kalexmills.stochrammar.runner;

import com.github.kalexmills.stochrammar.CFToken;
import com.github.kalexmills.stochrammar.StochasticGrammar;

import java.util.Arrays;
import java.util.Random;

/**
 * GroundSequenceRunner provides an algorithm for running a StochasticGrammar by only applying the act method of
 * GroundTokens which are produced. <b>Only</b> GroundTokens generated by the grammar are stored, and the act() methods
 * are applied by starting with a blankEntity instance, and applying each token in order of the generated sequence.
 *
 * The implementation used here involves double-buffering using two dynamic arrays. The buffers are not disposed of
 * between calls to run(), so if your grammars can generate strings of tokens which are particularly large, it is
 * certainly more memory efficient to have only one GroundSequenceRunner in memory that is shared by all clients.
 */
public class GroundSequenceRunner<T> extends GrammarRunner<T> {
    static final int DEFAULT_BUFFER_SIZE = 32;

    // Null-terminated buffers used to collect tokens as they are created.
    // N.B.: A more space-efficient implementation would probably use one set of buffers per running thread.
    private CFToken[] tokenBuffer;
    private CFToken[] backBuffer;

    public GroundSequenceRunner(StochasticGrammar<T> grammar) {
        super(grammar);
        tokenBuffer = new CFToken[DEFAULT_BUFFER_SIZE];
        backBuffer = new CFToken[DEFAULT_BUFFER_SIZE];
    }

    /**
     * Stochastically generates a new object of type T using the Random instance passed. This runner ignores all
     * non-ground tokens.
     *
     * @param rand Random a pre-seeded random number generator to be used for the generation.
     * @return T an instance of type T which results from the generation.
     */
    public T run(Random rand) {
        generateSequence(rand);
        return generateEntity();
    }

    /**
     * Uses the grammar to produce a sequence of tokens.
     * @param rand
     */
    private void generateSequence(Random rand) {
        // While a faster implementation might do some extra work to avoid calls to known GroundTokens, this will
        // only yield a practical speedup in the presence of a very large number of tokens. It may become necessary
        // at some later stage.
        tokenBuffer[0] = grammar.generateRootToken();
        tokenBuffer[1] = null;

        boolean tokensChanged = true;

        // Generates a sequence of GroundTokens.
        while (tokensChanged) {
            tokensChanged = false;

            int i = 0; // i indexes tokenBuffer
            int j = 0; // j indexes backBuffer
            while(i < tokenBuffer.length && tokenBuffer[i] != null) {
                CFToken[] tokens = tokenBuffer[i++].replace(rand);
                if(tokens.length != 0) {
                    tokensChanged = true;
                    // Insert new tokens
                    for (int k = 0; k < tokens.length; k++) {
                        backBuffer[j++] = tokens[k];
                        if(j >= backBuffer.length) extendBackBuffer();
                    }
                } else {
                    // We received an empty array. This was a ground token, so let's not overwrite it on the next pass.
                    backBuffer[j++] = tokenBuffer[i-1];
                    if(j >= backBuffer.length) extendBackBuffer();
                }
            }
            // Ensure back buffer remains null-terminated.
            backBuffer[j] = null;
            if(tokensChanged) {
                swapBuffers();
            }
        }
    }

    private T generateEntity() {
        // Each token acts on a blankEntity instance of type T, in sequence.
        T result = grammar.blankEntity();
        int i = 0;
        while (tokenBuffer[i] != null) {
            result = ((CFToken<T>)tokenBuffer[i++]).act(result);
        }
        return result;
    }

    /**
     * extendBackBuffer doubles the size of the back buffer. This change eventually propagates to the front buffer,
     * which means it is usually invoked twice whenever extensions are needed.
     */
    private void extendBackBuffer() {
        backBuffer = Arrays.copyOf(backBuffer, backBuffer.length * 2);
    }

    /**
     * swapBuffers swaps the front and back buffers.
     */
    private void swapBuffers() {
        CFToken[] temp = tokenBuffer;
        tokenBuffer = backBuffer;
        backBuffer = temp;
    }
}